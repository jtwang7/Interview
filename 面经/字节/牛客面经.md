# 一面
1. 操作系统线程进程的区别
[my-issue: JS - 进程与线程](https://github.com/jtwang7/JavaScript-Note/issues/34)
```js
1. 线程在进程下行进
2. 一个进程可以包含多个线程
3. 不同进程间数据很难共享
4. 同一进程下不同线程间数据易共享
5. 进程要比线程消耗更多的计算机资源
6. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉
7. 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
8. 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。
9. 进程使用的内存地址可以限定使用量
```
2. OSI 七层模型 (每层的功能/有什么协议)
```js
从上到下有：
1. 应用层：[HTTP，FTP，TELNET，SMTP]
   为应用程序提供服务并规定应用程序中通讯相关的细节。
2. 表示层：[ASCII，SSL/TLS]
   主要负责数据格式的转换和包装，将设备固有的数据格式转换为网络标准格式，数据的压缩、加密、打包等功能也都在这层完成。
3. 会话层：[ADSP，RPC]
   负责建立和断开通信连接，以及数据的分割等数据传输相关的管理。
4. 传输层：[TCP，UDP]
   管理两端节点间的数据传输。
   > 数据从发送端传到接收端，可能需要经过多段传输，传输层维护的是一段内的数据传输。
5. 网络层：[IP，ICMP]
   寻址和路由选择，将数据传输到目标地址。
   > 数据从发送端发送到接收端，两端间可能会存在很多数据链路，网络层负责找出一条相对顺畅的通路将数据传递过去。
6. 数据链路层：[HDLC，PPP，SLIP]
   负责物理层面上互连的节点之间的通信传输。数据链路层会将 0，1 序列划分为具有意义的数据帧传送给对端 [生成数据帧]
   > 数据链路层只负责将数据运送给物理相连的两端，并不负责直接发送到最终地址。
7. 物理层：
   将数据的 0、1 转换成电信号或者光信号。通过光纤、双绞线甚至是无限电波等介质传输到指定的地址。
```
3. HTTP2.0 新特性
```js
1. 头部压缩：HPACK算法压缩请求头体积
2. 二进制分帧：将报文格式从文本变为二进制，方便传递和解析
3. 多路复用：二进制帧组成“流”发送，一个TCP连接上可以乱序传输多条“流”，接收端根据“流”标志重新组织得到数据
   > 不同“流”之间传递可以是乱序的，因为有 Stream ID 标识。
   > 而相同“流”之间的帧一定是按顺序传递的，接收方需要从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。
4. 请求优先级：数据分帧后，可以通过调整帧的传输顺序，进一步优化性能
5. 服务器推送：实现数据的双向传输，服务器不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息
```
4. TCP 和 UDP 区别
[my-issue: TCP 与 UDP](https://github.com/jtwang7/Internet-Note/issues/5)

|  | UDP | TCP |
-- | -- | --
是否连接 | 无连接 | 面向连接
是否可靠 | 不可靠传输，不使用流量控制和拥塞控制 | 可靠传输，使用流量控制和拥塞控制
连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信
传输方式 | 面向报文 | 面向字节流
首部开销 | 首部开销小，仅8字节 | 首部最小20字节，最大60字节
适用场景 | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输

5. webpack 有哪些常用的 loader / plugin ?
```js
loader：
1. image-loader：加载并压缩图片文件。
2. babel-loader：把ES6转换为ES5。
3. css-loader：加载CSS，支持模块化、压缩、文件导入等特性。
4. style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS。
5. eslint-loader：通过ESlint检查JavaScript代码。

plugin：
1. define-plugin：定义环境变量。
2. commons-chunk-plugin：提取公共代码。
3. uglifyjs-webpack-plugin：缩小（压缩优化）js文件
```

6. webpack 热更新原理
```js
热更新/热替换 [Hot Module Replacement, HMR]。 
作用：不用刷新浏览器而将新变更的模块替换掉旧的模块。
原理：WDS(无限分布式系统)与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器主动推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起  Ajax 请求来获取更改的内容清单 [文件列表 + hash]，这样客户端就可以再根据更新清单继续向 WDS 发起  jsonp 请求获取该 chunk 的增量更新。
```

7. webpack 构建流程
```js
1. 读取webpack的配置参数；
2. 启动webpack，加载Plugin，创建Compiler对象并开始解析项目；
3. 从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；
4. 对不同文件类型的依赖模块文件使用对应的Loader进行编译，最终转为Javascript文件；
5. 将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中
5. 整个过程中webpack会通过发布订阅模式，向外抛出一些hooks，而webpack的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。
```

# 二面
1. 排序算法 (时间复杂度/最好情况/最坏情况)
[my-issue: CodeShredded - 排序算法](https://github.com/jtwang7/Code-Shredded/issues/18)

2. 深拷贝
[my-issue: CodeShredded - 拷贝](https://github.com/jtwang7/Code-Shredded/issues/19)

3. 事件委托
```js
事件委托是“过多事件处理程序”的解决方案，利用了事件冒泡的机制，给元素的共同祖先节点添加一个事件处理程序，来管理一种类型的事件。
优点：
1. 节省设置页面事件处理程序的时间
2. 减少整个页面所需的内存
```

4. 事件冒泡/捕获
```js

```